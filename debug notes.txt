dom.go

line 509
		// Determine the next child render.
		nextChildRender, skip, mounters := render(nextChild, prevChild)
		if nextChildRender != nil && prevChildRender != nil && nextChildRender == prevChildRender {
			log.Printf("%v", "vecty/dom/vecty.HTML.reconcileChildren()1 vecty: next 'child render' must not equal previous 'child render' (did the 'child Render' illegally return a stored render variable?)")
			log.Printf("%v %v %p %+v %v %p %+v %v %v %v %v", "vecty/dom/vecty.HTML.reconcileChildren()1", "nextChild =", nextChild, nextChild, "prevChild =", prevChild, prevChild, "nextChildRender =", nextChildRender, "prevChildRender =", prevChildRender)
			//panic("vecty: next 'child render' must not equal previous 'child render' (did the 'child Render' illegally return a stored render variable?)")
		}


line 646
func (h *HTML) removeChild(child *HTML) {
	// If we're removing the current insert target, use the next
	// sibling, if any.
	log.Printf("%v %v %p %+v %v %+v %v %p %+v", "vecty/dom/vecty.HTML.removeChild()1", "child =", child, child, "child.node =", child.node, "h =", h, h)
	if h.insertBeforeNode != nil && h.insertBeforeNode.Equal(child.node) {
		h.insertBeforeNode = h.insertBeforeNode.Get("nextSibling")
	}
	unmount(child)
	if child.node == nil {
		return
	}
	// Use the child's parent node here, in case our node is not a valid
	// target by the time we're called.
	pn := child.node.Get("parentNode")
	log.Printf("%v %v %+v", "vecty/dom/vecty.HTML.removeChild()2", "child.node.Get('parentNode') =", pn)
	child.node.Get("parentNode").Call("removeChild", child.node)
}






